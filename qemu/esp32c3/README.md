# Overview

This page provides some ESP-specific instructions for running QEMU. Refer to the official documentation for general QEMU usage questions: https://www.qemu.org/documentation/.

# Compiling QEMU

## Prerequisites

Beforehand, please check QEMU documentation regarding build prerequisites. If you are building QEMU on a Linux host, you can refer to [this page](https://wiki.qemu.org/Hosts/Linux#Building_QEMU_for_Linux).

In addition to QEMU's prerequisites, make sure that `libgcrypt` is installed on your system (`libgcrypt-devel` on Ubuntu, `libgcrypt` on Arch, `libgcrypt` on macOS Homebrew).

## Configure

To generate the `ninja` build files, we need to configure the project first, the following command can be used for that:

```bash
./configure --target-list=riscv32-softmmu \
    --enable-gcrypt \
    --enable-slirp \
    --enable-debug --enable-sanitizers \
    --disable-strip --disable-user \
    --disable-capstone --disable-vnc \
    --disable-sdl --disable-gtk
```

To reduce the first compilation time, feel free to add more `--disable` options. The complete list of options that can be enabled or disabled can be obtained with `./configure --help` command.

## Build

After configuring the project successfully, `ninja` can be used to build it:

```
ninja -C build
```

Compilation can take a few minutes depending on the components that were enabled or disabled previously. Upon completion, `build/qemu-system-xtensa` should be created.

# Compiling the ESP-IDF program to emulate

QEMU for ESP32-C3 target is ready, it already includes the first stage bootloader, located on the ROM on the real chip, which is mainly responsible for initializing the peripherals, like the UART and, more importantly, the SPI Flash. The latter **must** contain the second stage bootloader and the program to run.

Thus, in this section, we are going to create a flash image that combines the (second stage) bootloader, the partition table and the application to run. This can be done using `esptool.py merge_bin` command, supported in `esptool.py` 3.1 or later. Let's suppose that the ESP-IDf project has just been compiled successfully, the following commands will create that flash image:

```bash
cd build
esptool.py --chip esp32c3 merge_bin --fill-flash-size 4MB -o flash_image.bin @flash_args
```

Here, `flash_args` is a file generated by ESP-IDF build system in the build directory, it contains the list of names of binary files and corresponding flash addresses. `merge_bin` command takes this list and creates the binary image of the whole flash. `--fill-flash-size 4MB` argument specifies the total flash size.

ESP32-C3 target in QEMU supports flash of size 2, 4, 8 and 16MB, creating an image with any other size will result in an error.

**Notes**

* "Secure Boot" feature is not supported yet for ESP32-C3 target.

* It is also possible to use `esptool.py` to "flash" the application into QEMU, but QEMU needs to be started with the right strapping mode. [See Bootstrapping Mode section below for more info](#specifying-bootstrapping-mode).

# Run QEMU

## Without attaching GDB

If you don't need to debug the guest application, you can execute QEMU without attaching GDB to it:
```
build/qemu-system-riscv32 -nographic \
    -icount 3 \
    -machine esp32c3 \
    -drive file=flash_image.bin,if=mtd,format=raw
```
Where `flash_image.bin` is the SPI flash image generated previously.

It is important to specify `-icount` parameter as the current implementation does not support "free running" mode. When `-icount 3` is specified, each instruction of the emulated ESP32-C3 machine takes `1 << 3 = 8ns` to be executed. In other words, this will emulate a 125MHz ESP32-C3.

## With GDB server, waiting for a connection

If you need to debug the guest application, you can execute QEMU with `-s -S` options. This tells QEMU not to start the CPU after initializing the virtual machine. It will wait for a connection from a GDB client:
```
build/qemu-system-riscv32 -nographic -s -S \
    -icount 3 \
    -machine esp32c3 \
    -drive file=flash_image.bin,if=mtd,format=raw
```
Where `flash_image.bin` is the SPI flash image generated previously.

Then, to connect the GDB client, use the following command:
```
riscv32-esp-elf-gdb build/app-name.elf \
    -ex "target remote :1234" \
    -ex "tb app_main" -ex "c"
```
The last line sets a breakpoint in `app_main` function of the guest application and starts the virtual CPU with `c`. If you need to put a breakpoint in any other functions or if you don't need to start the CPU directly, please adapt this last line.

## Hardware crypto support

Currently, ESP32-C3 QEMU implementation only supports SHA and AES, **without** DMA.

If your project needs any of the unsupported crypto features, consider disabling them in the `menuconfig` beforehand.

## Specifying bootstrapping mode

To specify the desired strapping mode, it is necessary to add the following argument when running QEMU:

```
-global driver=esp32c3.gpio,property=strap_mode,value=0x08
```

This sets the value of `GPIO_STRAP` register.
* Use `0x08` for SPI flash boot mode (default)
* Use `0x02` for UART0 download mode

## Specifying eFuse storage

By default, if no eFuse storage is specified on the command line, the emulated eFuses will all be set to 0, except the `WAFER_VERSION_MINOR` one, which represents the ECO version of the chip.

It is possible to manually create a binary file that will be used as eFuse blocks during the emulation. This is very handy if the application to test makes use of the eFuses, MAC address or encryption keys.

To use a file as eFuse blocks, you only need to add the following arguments when running QEMU:

```
-drive file=qemu_efuse.bin,if=none,format=raw,id=efuse
-global driver=nvram.esp32c3.efuse,property=drive,value=efuse
```

The first argument creates a block device backed by `qemu_efuse.bin` file, with identifier `efuse`. The second line configures `nvram.esp32c3.efuse` device to use this block device for storage.

The file must be existing when invoking the command above. To create it beforehand, the following command can be used:

```
dd if=/dev/zero bs=1KiB count=1 of=qemu_efuse.bin
```

This command creates a 1KB (1024 bytes) file, which is the total size of ESP32-C3 eFuse blocks, filled with zeros.

When providing a binary file as eFuses blocks, it is required to manually set the ECO version. The `WAFER_VERSION_MINOR` eFuse responsible for that is a 3-bit value starting at bit 2 of byte `0x26`.

For example, here is the minimum eFuse file for a v0.3 ESP32-C3 (in hexadecimal, produced using `xxd -p`):
```
000000000000000000000000000000000000000000000000000000000000
00000000000000000c000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000
00000000

```

To convert this (`efuse.hex`) back to binary, run `xxd -r -p efuse.hex qemu_efuse.bin`.

## Using esptool.py and espefuse.py to interact with Qemu

1. Start QEMU:
    ```
    build/qemu-system-riscv32 -nographic \
        -machine esp32c3 \
        -drive file=flash_image.bin,if=mtd,format=raw \
        -global driver=esp32c3.gpio,property=strap_mode,value=0x02 \
        -drive file=qemu_efuse.bin,if=none,format=raw,id=efuse \
        -global driver=nvram.esp32c3.efuse,property=drive,value=efuse \
        -serial tcp::5555,server,nowait
    ```

    The final line redirects the emulated UART to TCP port 5555 (QEMU acts as a server).

    Type q and press Enter at any time to quit.

1. Run `esptool.py`:

    ```
    esptool.py -p socket://localhost:5555 \
    --chip esp32c3 --no-stub --before no_reset --after no_reset \
    flash_id
    ```

    Flashing using `esptool.py` also works:

    ```
    $ cd your_idf_project
    $ cd build/
    $ esptool.py -p socket://localhost:5555 --chip esp32c3 \
      --no-stub --before no_reset --after no_reset write_flash @flash_args
    ```

Note: `esptool` can **not** reset the emulated chip using the RTS signal, because the state of RTS is not transmitted over TCP to QEMU. To reset the emulated chip, run `system_reset` command in QEMU console (started at step 1).

## Specifying ROM ELF file

If `-kernel` and `-bios` arguments are not given, ESP32-C3 ROM code will be loaded. This ROM code binary is included in the repository. To specify the ROM code ELF file to load, pass the filename with a `-bios <filename>` argument.
